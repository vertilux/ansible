---
# Play 1: preparar lote y avisar inicio
- name: Build transient group and announce start
  hosts: localhost
  gather_facts: no
  vars:
    selected_droplets: "{{ droplet_names | default([]) }}"
    slack_webhook_url: "{{ SLACK_WEBHOOK_URL | default('') }}"
    start_epoch: "{{ lookup('pipe', 'date +%s') }}"

    # Mapa nombre -> IP (no cambia tu inventario actual)
    droplet_map:
      production-lb01: 165.227.210.87
      production-lb02: 159.203.94.161
      production-lb03: 134.209.34.218
      production-lb04: 134.209.34.40
      load-balancer: 167.99.60.242
      db-replication: 104.236.149.105
      production-db: 104.236.33.109
      contract: 107.170.0.247
      postgres-etf: 134.209.124.111
      restful-api: 137.184.63.106
      erp-test-stage: 165.227.69.194
      sunlux: 45.55.36.150

  tasks:
    - name: Validate survey input
      assert:
        that: selected_droplets | length > 0
        fail_msg: "âŒ You must select at least one droplet by name."
        success_msg: "âœ… Selected droplets: {{ selected_droplets | join(', ') }}"

    - name: Build mapping only for selected droplets
      set_fact:
        droplet_ips: "{{ droplet_ips | default({}) | combine({item: droplet_map[item]}) }}"
      loop: "{{ selected_droplets }}"
      when: droplet_map[item] is defined

    - name: Fail if any droplet is missing in map
      assert:
        that: droplet_ips | length == selected_droplets | length
        fail_msg: "âŒ Some selected droplets are missing from droplet_map."
        success_msg: "âœ… All selected droplets resolved to IPs."

    - name: Create transient group 'reboot_batch'
      add_host:
        name: "{{ item.key }}"
        ansible_host: "{{ item.value }}"
        groups: reboot_batch
      loop: "{{ droplet_ips | dict2items }}"

    - name: Notify start on Slack (once)
      when: slack_webhook_url | length > 0
      run_once: true
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body_format: json
        body:
          text: "âš™ï¸ Starting sequential reboot of: {{ selected_droplets | join(', ') }}"
      changed_when: false
      ignore_errors: true

    # exportar variables a plays siguientes
    - name: Share facts for later plays
      set_stats:
        data:
          reboot_selected: "{{ selected_droplets }}"
          reboot_map: "{{ droplet_ips }}"
          reboot_start_epoch: "{{ start_epoch }}"
          slack_url_shared: "{{ slack_webhook_url }}"

# Play 2: reiniciar, uno por uno, con mensajes por host y tolerando fallas
- name: Sequentially reboot selected droplets
  hosts: reboot_batch
  gather_facts: no
  serial: 1
  become: yes

  vars:
    slack_webhook_url: "{{ hostvars['localhost']['slack_url_shared'] | default('') }}"

  tasks:
    - name: Announce per-host reboot to Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body_format: json
        body:
          text: "ðŸ”„ Rebooting *{{ inventory_hostname }}* ({{ ansible_host }})..."
      changed_when: false
      ignore_errors: true

    # Usamos reboot y esperamos reconexiÃ³n. Si el host estÃ¡ muy mal (disco lleno, etc),
    # puede fallar; lo toleramos y seguimos con el resto.
    - name: Reboot host
      reboot:
        reboot_timeout: 180
        test_command: "uptime"
      register: rb
      ignore_errors: true

    - name: Pause between droplets
      pause:
        seconds: 2

    - name: Report per-host result to Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body_format: json
        body: >-
          {% if (rb is succeeded) and (rb.rebooted | default(false)) %}
          {"text":"âœ… *{{ inventory_hostname }}* rebooted successfully."}
          {% else %}
          {"text":"âš ï¸ *{{ inventory_hostname }}* reboot failed or did not confirm."}
          {% endif %}
      changed_when: false
      ignore_errors: true

    - name: Aggregate results
      set_stats:
        aggregate: true
        data:
          reboot_summary: >-
            {{ (reboot_summary | default([])) +
               [ { 'name': inventory_hostname,
                   'ip': ansible_host,
                   'ok': (rb is succeeded) and (rb.rebooted | default(false)) } ] }}

# Play 3: resumen final y tiempo total
- name: Final Slack summary
  hosts: localhost
  gather_facts: no
  vars:
    slack_webhook_url: "{{ hostvars['localhost']['slack_url_shared'] | default('') }}"
    start_epoch: "{{ hostvars['localhost']['reboot_start_epoch'] | int }}"
    end_epoch: "{{ lookup('pipe','date +%s') | int }}"
    elapsed_sec: "{{ end_epoch - start_epoch }}"
    elapsed_str: "{{ (elapsed_sec // 60) | int }}m {{ (elapsed_sec % 60) | int }}s"

  tasks:
    - name: Build success/failure counts
      set_fact:
        _sum: "{{ hostvars['localhost']['reboot_summary'] | default([]) }}"
        ok_count: "{{ (_sum | selectattr('ok', 'equalto', true) | list) | length }}"
        fail_count: "{{ (_sum | selectattr('ok', 'equalto', false) | list) | length }}"
        names_ok: "{{ _sum | selectattr('ok','equalto',true) | map(attribute='name') | list }}"
        names_fail: "{{ _sum | selectattr('ok','equalto',false) | map(attribute='name') | list }}"

    - name: Send final Slack message (once)
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body_format: json
        body:
          text: >-
            âœ… Reboot sequence completed in {{ elapsed_str }}.
            *Success:* {{ ok_count }} | *Failed:* {{ fail_count }}
            {% if names_ok|length>0 %}â€¢ OK: {{ names_ok | join(', ') }}{% endif %}
            {% if names_fail|length>0 %}â€¢ Failed: {{ names_fail | join(', ') }}{% endif %}
      changed_when: false
      ignore_errors: true
