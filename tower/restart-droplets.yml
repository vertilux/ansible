---
# 1ï¸âƒ£ Primer play: construir el grupo dinÃ¡mico
- name: Build transient group with selected droplets
  hosts: localhost
  gather_facts: no

  vars:
    selected_droplets: "{{ droplet_names | default([]) }}"
    slack_webhook_url: "{{ SLACK_WEBHOOK_URL | default('') }}"
    start_time: "{{ lookup('pipe', 'date +%s') }}"
  droplet_map:
      production-lb01: 165.227.210.87
      production-lb02: 159.203.94.161
      production-lb03: 134.209.34.218
      production-lb04: 134.209.34.40
      load-balancer: 167.99.60.242
      db-replication: 104.236.149.105
      production-db: 104.236.33.109
      contract: 107.170.0.247
      postgres-etf: 134.209.124.111
      restful-api: 137.184.63.106
      erp-test-stage: 165.227.69.194
      sunlux: 45.55.36.150

  tasks:
    - name: Validate survey input
      assert:
        that: selected_droplets | length > 0
        fail_msg: "âŒ You must select at least one droplet by name."
        success_msg: "âœ… Selected droplets: {{ selected_droplets | join(', ') }}"

    - name: Resolve selected droplets using droplet_map
      set_fact:
        droplet_ips: "{{ droplet_ips | default({}) | combine({item: droplet_map[item]}) }}"
      loop: "{{ selected_droplets }}"
      when: droplet_map[item] is defined

    - name: Fail if any droplet is missing in map
      assert:
        that: droplet_ips | length == selected_droplets | length
        fail_msg: "âŒ Some selected droplets are missing from droplet_map."
        success_msg: "âœ… All selected droplets resolved to IPs."

    - name: Create transient group 'reboot_batch'
      add_host:
        name: "{{ item.key }}"
        ansible_host: "{{ item.value }}"
        groups: reboot_batch
      loop: "{{ droplet_ips | dict2items }}"

    - name: Notify global start on Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body_format: json
        body:
          text: "âš™ï¸ Starting sequential reboot of *{{ selected_droplets | join(', ') }}* droplets..."
      changed_when: false
      ignore_errors: true


---
# 2ï¸âƒ£ Segundo play: reinicio secuencial real (uno por uno)
- name: Sequentially reboot selected droplets
  hosts: reboot_batch
  gather_facts: false
  serial: 1
  vars:
    slack_webhook_url: "{{ SLACK_WEBHOOK_URL | default('') }}"

  tasks:
    - name: Announce droplet reboot on Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers: { Content-Type: "application/json" }
        body_format: json
        body:
          text: "ðŸ”„ Rebooting *{{ inventory_hostname }}* ({{ ansible_host }})..."
      changed_when: false
      ignore_errors: true

    - block:
        - name: Try normal Ansible reboot
          become: true
          reboot:
            reboot_timeout: 120
            test_command: "uptime"
          register: reboot_result
          ignore_errors: true

        - name: Fallback reboot (for low disk or hung systems)
          when: reboot_result is failed
          shell: "nohup /usr/bin/sudo /sbin/shutdown -r now >/dev/null 2>&1 &"
          async: 1
          poll: 0
          ignore_errors: true

        - name: Wait 2 seconds before checking
          pause:
            seconds: 2

        - name: Wait for droplet to come back online
          wait_for_connection:
            delay: 2
            timeout: 90
          register: back_up
          ignore_errors: true

      always:
        - name: Determine reboot success
          set_fact:
            reboot_success: >-
              {{ (reboot_result is defined and reboot_result is succeeded)
              or (back_up is defined and back_up is succeeded) }}

        - name: Record droplet result
          set_fact:
            reboot_results_all: "{{ reboot_results_all | default({}) | combine({inventory_hostname: reboot_success}) }}"

        - name: Notify Slack of result
          when: slack_webhook_url | length > 0
          uri:
            url: "{{ slack_webhook_url }}"
            method: POST
            headers: { Content-Type: "application/json" }
            body_format: json
            body: >-
              {% if reboot_success %}
              {"text":"âœ… *{{ inventory_hostname }}* rebooted successfully."}
              {% else %}
              {"text":"âš ï¸ *{{ inventory_hostname }}* reboot failed or unresponsive."}
              {% endif %}
          changed_when: false
          ignore_errors: true

        - name: Pause before next droplet
          pause:
            seconds: 2


---
# 3ï¸âƒ£ Tercer play: resumen general en Slack
- name: Summarize reboot results
  hosts: localhost
  gather_facts: no
  vars:
    slack_webhook_url: "{{ SLACK_WEBHOOK_URL | default('') }}"
    end_time: "{{ lookup('pipe', 'date +%s') }}"
  tasks:
    - name: Compute total time
      set_fact:
        elapsed_seconds: "{{ end_time | int - start_time | int }}"
        elapsed_minutes: "{{ (end_time | int - start_time | int) // 60 }}"

    - name: Build Slack summary
      set_fact:
        summary_msg: |
          {% set total = reboot_results_all | length %}
          {% set ok = reboot_results_all | dict2items | selectattr('value','equalto',true) | list | length %}
          {% set failed = total - ok %}
          âœ… *{{ ok }}/{{ total }}* droplets rebooted successfully.
          {% if failed > 0 %}
          âŒ *{{ failed }}* failed: {{ reboot_results_all | dict2items | selectattr('value','equalto',false) | map(attribute='key') | join(', ') }}
          {% endif %}
          â±ï¸ Total time: {{ elapsed_seconds }} sec

    - name: Send summary to Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers: { Content-Type: "application/json" }
        body_format: json
        body:
          text: "{{ summary_msg }}"
      changed_when: false
      ignore_errors: true
