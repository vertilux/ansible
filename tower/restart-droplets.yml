---
- name: Build transient group with selected droplets
  hosts: localhost
  gather_facts: no

  vars:
    selected_droplets: "{{ droplet_names | default([]) }}"
    slack_webhook_url: "{{ SLACK_WEBHOOK_URL | default('') }}"

  tasks:
    - name: Validate survey input
      assert:
        that: selected_droplets | length > 0
        fail_msg: "‚ùå You must select at least one droplet by name."
        success_msg: "‚úÖ Selected droplets: {{ selected_droplets | join(', ') }}"

    - name: Resolve selected droplets to IPs (from inventory)
      set_fact:
        droplet_ips: "{{ droplet_ips | default({}) | combine({item: hostvars[item].ansible_host}) }}"
      loop: "{{ selected_droplets }}"
      when: hostvars[item] is defined

    - name: Fail if any droplet lacks IP in inventory
      assert:
        that: droplet_ips | length == selected_droplets | length
        fail_msg: "‚ùå Some selected droplets are missing IPs in the inventory."
        success_msg: "‚úÖ All selected droplets have IPs."

    - name: Create transient group 'reboot_batch'
      add_host:
        name: "{{ item.key }}"
        ansible_host: "{{ item.value }}"
        groups: reboot_batch
      loop: "{{ droplet_ips | dict2items }}"

    - name: Send global start message to Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers:
          Content-Type: "application/json"
        body_format: json
        body:
          text: "‚öôÔ∏è Starting sequential reboot of *{{ selected_droplets | join(', ') }}* droplets..."
      changed_when: false
      ignore_errors: true


# Segundo play ‚Äî reinicios reales
- name: Sequentially reboot selected droplets
  hosts: reboot_batch
  gather_facts: false
  serial: 1
  vars:
    slack_webhook_url: "{{ SLACK_WEBHOOK_URL | default('') }}"
  tasks:
    - name: Announce droplet reboot on Slack
      when: slack_webhook_url | length > 0
      uri:
        url: "{{ slack_webhook_url }}"
        method: POST
        headers: { Content-Type: "application/json" }
        body_format: json
        body:
          text: "üîÑ Rebooting *{{ inventory_hostname }}* ({{ ansible_host }})..."
      changed_when: false
      ignore_errors: true

    - block:
        - name: Try normal Ansible reboot first
          become: true
          reboot:
            reboot_timeout: 180
            test_command: "uptime"
          register: reboot_result
          ignore_errors: true

        - name: Force fallback reboot if needed (handles low disk)
          when: reboot_result is failed
          shell: "nohup /usr/bin/sudo /sbin/shutdown -r now >/dev/null 2>&1 &"
          async: 1
          poll: 0
          register: forced_reboot
          ignore_errors: true

        - name: Wait 15 seconds before checking
          pause:
            seconds: 15

        - name: Wait for droplet to come back online
          wait_for_connection:
            delay: 10
            timeout: 120
          register: back_up
          ignore_errors: true

      rescue:
        - debug:
            msg: "‚ö†Ô∏è Rescue: {{ inventory_hostname }} encountered reboot failure."

      always:
        - name: Determine reboot success
          set_fact:
            reboot_success: >-
              {{ (reboot_result is defined and reboot_result is succeeded)
              or (back_up is defined and back_up is succeeded) }}

        - name: Notify Slack of reboot result
          when: slack_webhook_url | length > 0
          uri:
            url: "{{ slack_webhook_url }}"
            method: POST
            headers: { Content-Type: "application/json" }
            body_format: json
            body: >-
              {% if reboot_success %}
              {"text":"‚úÖ *{{ inventory_hostname }}* rebooted successfully."}
              {% else %}
              {"text":"‚ùå *{{ inventory_hostname }}* reboot failed or did not respond in time."}
              {% endif %}
          changed_when: false
          ignore_errors: true

        - name: Wait 15 seconds before next droplet
          pause:
            seconds: 15
